# Простые задачи на яваскрипт

Сразу расскажу про несколько особенностей яваскрипта, о которых может быть не написано (или мало написано) в учебниках, но которые стоит понимать:

### Строгий режим

В новом Javascript есть строгий режим: 

- http://learn.javascript.ru/strict-mode
- http://habrahabr.ru/post/118666/

В нем некоторые ошибки, которые ранее прощались, становятся фатальными. Обязательно используй этот режим при решении задач.

### Функции и замыкания

Функции — это объекты. У них есть свойства (например `length`) и методы (например `toSource`, `apply` и `call`). Функции можно хранить в переменных, передавать и возвращать из других функций: 

    var a = function (..) { ... }; // создаем новую функцию и поменщаем ссылку в a
    a(); // вызываем
    console.log(a.toSource()); // вызваем метод у функции (он вернет ее текст)

Функция **при создании** привязывается к набору переменных родительской функции и потому видит ее переменные:

    function f1() {
        var a = 1;
        var b = 2;
    
        function f2() {
            var d = 3;
            var e = 4;
            
            ...(код 2)..
            
            return function () {
                var f = 5;
                ...(код 3)...
            };
        }
        
        ...(код 1)...
    }

- Код 1 видит переменные a, b и функцию f2 (и f1 тоже)
- Код 2 видит свои переменные d, e, а также родительские a, b, и f2  (и f1 тоже)
- Код 3 видит переменную f, а также d, e, a, b, f2 (и f1 тоже)

То есть внутренняя функции видит переменные внешней функции, которые были в момент ее создания. Это называется замыкание.

Внешняя функция не видит переменных внутренней. Код, находящийся вне функций, в глобальном контексте, не видит внутренние (локальные) переменные.

### Порядок создания переменных

Локальные переменные (объявленные через var) создаются при входе в функцию, до выполнения ее кода. При этом им изначально присваивается undefined:

        function test() {
            console.log(a); // undefined
        
            var a = 2; 
            console.log(a); // 2
        }
        
        test();

Этот код выполняется так:

- создать переменную `a` и присвоить ей `undefined`
- выполнить первый console.log
- присвоить `a` значение 2
- выполнить второй console.log

### Копирование по значению и по ссылке

Примитивные значения дублируются при копировании, копирование объектов просто копирует ссылку на один и тот же объект. Примитивные значения — это не-объекты, то есть `null`, `undefined`, числа, `true`/`false`, строки. Если ты их присваиваешь переменной, передаешь или возвращаешь из функции, создается новая независимая копия значения:

    var a = "Hello";
    var b = a; // В b независимая копия строки. Меняя ее, мы не изменяем то, что в a
    
Объекты (а это в том числе массивы (Array), функции (Function), регулярки (RegExp), даты (Date)) копируются и передаются в/из функции по ссылке:

    var a = { x: 1, y: 2 };
    var b = a; // в b ссылка на тот же самый объект, что и в a. Проверим:
    b.x = 10;
    console.log(a.x); // 10
    
    var с = [];
    function changeArray(arr) { arr.push(1); } 
    changeArray(с); // в функцию передается не копия, а ссылка на тот же массив. 
    console.log(c); // [1]
    
### Сравнение объектов

Объекты (а значит и массивы, и функции, так как они тоже ими являются) сравниваются по идентичности, то есть тому, что это ссылки на один и тот же объект: 

    var a = {};
    var b = a;
    console.log(a === b);  // true
    var c = {};
    var d = {};
    conslole.log(c === d); // false
    
Во втором случае у нас 2 разных объекта и получается `false`. `{}` всегда создает **новый** объект. По этой причине `{} === {}`, `[] === []`, `function(){} === function(){}` всегда дают `false`. И вообще, любое сравнение объекта с `[]` или `{}` даст `false`. 

Подробнее: http://javascript.ru/comparison-operators

### Ложные и правдивые значения

Falsy (ложных? лживеньких?) значений ровно 7, их надо знать наизусть: `0`, `-0` (да, в программировании есть отрицательный ноль), `NaN`, `null`, `undefined`, `''` (пустая строка), `false`. Все остальные значения truthy, в том числе `'0'` (строка из символа 0). При преобразовании в логический (булев) тип falsy значения преовращаются в `false`, а все остальные — в `true`:

    console.log(0 ? "truthy" : "falsy"); // falsy
    console.log('0' ? "truthy" : "falsy"); // truthy
    console.log({} ? "truthy" : "falsy"); // truthy
    console.log([] ? "truthy" : "falsy"); // truthy
    console.log('' ? "truthy" : "falsy"); // falsy
    if (1) { console.log('truthy'); } else { console.log('falsy'); } // truthy
    
### Боксинг
    
У примитивных значений (примитивные = не-объекты, то есть числа, строки, `true`/`false`/`null`/`undefined`) нет свойств и методов (они есть только у объектов). При попытке обратиться к свойствам/методам примитивов происходит *боксинг*: яваскрипт создает временный объект из примитива и обращается к нему (сам примитив остается неизменным). Для чисел создается объект «класса» Number, для `true`/`false` Boolean, для строк — String. Для `null` и `undefined` выдается ошибка. То есть код

    var a = "abc";
    var b = a.length;
    
Превращается внутри в:

    var a = "abc";
    var tmp = new String(a); // происходит боксинг, создается временный объект
    var b = tmp.length; // и идет обращение к свойству этого объекта
    // почле чего объект выкилдывается
    
Потому присвоить свойство примитиву можно, но оно не сохранится — ведь оно создалось на временном объекте.

    var x = 1;
    x.test = 2;
    console.log('test' in x); // false — такого свойства у x нету
    
Это легко объяснить, если записать что происходит с учетом боксинга:

    var x = 1;
    var tmp1 = new Number(x);
    tmp1.test = 2; // свойство присвоилось временному объекту
    var tmp2 = new Number(x);
    console.log('test' in tmp2); // а ищем мы его уже в другом объекте, естественно его там нет
    
## Задачки на JS
    
1. Напиши функцию создания генератора `sequence(start, step)`. Она при вызове возвращает другую функцию-генератор, которая при каждом вызове дает число на 1 больше, и так до бесконечности. Начальное число, с которого начинать отсчет, и шаг, задается при создании генератора. Шаг можно не указывать, тогда он будет равен одному. Начальное значение по умолчанию равно 0. Генераторов можно создать сколько угодно.

        var generator = sequence(10, 3);
        var generator2 = sequence(7, 1);
        
        console.log(generator()); // 10
        console.log(generator()); // 13
        
        console.log(generator2()); // 7
        
        console.log(generator()); // 16
        
        console.log(generator2()); // 8

2. Также, нужна функция `take(gen, x)` которая вызвает функцию `gen` заданное число (`x`) раз и возвращает массив с результатами вызовов. Она нам пригодится для отладки:

        var gen2 = sequence(0, 2);
        console.log(take(gen2, 5)); // [0, 2, 4, 6, 8 ]


3. Напиши функцию `map(fn, array)`, которая принимает на вход функцию и массив, и обрабатывает каждый элемент массива этой функцией, возвращая новый массив. Пример: 
        
        function square(x) { return x * x; } // возведение в квадрат
        console.log(map(square, [1, 2, 3, 4])); // [1, 4, 9, 16]
        console.log(map(square, [])); // []

    Обрати внимание: функция не должна изменять переданный ей массив: 
    
        var arr = [1, 2, 3];
        console.log(map(square, arr)); // [1, 4, 9]
        console.log(arr); // [1, 2, 3]

    Это аналог `array_map` из PHP.

4. Напиши функцию `fmap(a, gen)`, которая принимает на вход 2 функции, `a` и `gen`, где `gen` — функция-генератор вроде той, что была в первом задании. `fmap` возвращает новую функцию-генератор, которая при каждом вызове берет следующее значение из `gen` и пропускает его через функцию `a`. Пример: 

        var gen = sequence(1, 1);
        function square(x) { return x * x; }
        var squareGen = fmap(square, gen);
        
        console.log(squareGen()); // 1
        console.log(squareGen()); // 4
        console.log(squareGen()); // 9
        console.log(squareGen()); // 16

    А, еще, сделай тогда, чтобы в качестве `gen` можно было указать функцию с аргументами, и при вызове

        function add(a, b) { 
            return a + b; 
        }
        
        // Мы получаем новую функцию, которая вызвает add, и результат пропускает через функцию square
        var squareAdd = fmap(square, add);
        console.log(squareAdd(2, 3)); // 25 = (2 + 3) ^ 2
        console.log(squareAdd(5, 7)); // 144 = (5 + 7) ^ 2

    Эти аргументы бы передавались функции `gen`. Аргументов может быть любое количество.

5. Частичное применение (partial application)

    вики: http://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5
    
    Напиши функцию `partial(fn, a1, a2, ....)`, которая позволяет зафиксировать один или несколько аргументов функции. Пример: 
    
        function add(a, b) { return a + b; }
        function mult(a, b, c, d) { return a * b * c * d; }
        
        var add5 = partial(add, 5); // Мы получили функцию с 1 аругментом, которая прибавляет к любому числу 5
        
        console.log(add5(2)); // 7
        console.log(add5(10)); // 15
        console.log(add5(8)); // 13
        
        var mult23 = partial(mult, 2, 3); // мы зафиксировали первые 2 аргумента mult() как 2 и 3
        
        console.log(mult23(4, 5)); // 2*3*4*5 = 120
        console.log(mult23(1, 1)); // 2*3*1*1 = 6

    Есть функция с аргументами: 

        f1(a, d, c, d)

    Мы можем с помощью `partial` сделать из нее функцию с меньшим числом аргументов, заранее задав значения для нескольких из них, например:
    
        var f2 = partial(f1, 1, 2); // фиксируем a = 1, b = 2
    
    И вызов:
    
        f2(x, y)
    
    будет равносилен вызову:
    
        f1(1, 2, x, y)
    
    Кстати, имеющийся в новых версиях JS метод `bind()` тоже может делать частичное применение: http://frontender.info/partial-application-in-javascript-using-bind/ Но ты должен обойтись без его использования, и написать свой велосипед.

6. Наша функция `partial` позволяет фиксировать только первые аргументы. Усовершенствуй ее, чтобы зафиксировать можно было любые аргументы, пропущенные аргументы обозначаются с помощью undefined:

        function test(a, b, c) { return 'a=' + a + ',b=' + b + ',c=' + c; }
        var test1_3 = partial(test, 1, undefined, 3);
        console.log(test1_3(5)); // a=1,b=5,c=3
    
7. напиши функцию `bind`, которая позволяет привязать контекст (значение `this`) к функции:

        window.x = 1;
        var ctx = { x: 2 };
    
        function testThis(a) { console.log("x=" + this.x + ", a=" + a); }
        console.log(testThis(100)); // x=1, a=100
        var boundFunction = bind(testThis, ctx);
        console.log(boundFunction(100)); // x=2, a= 100

    В новых браузерах и функций есть метод `bind()`, делающий аналогичную вещь: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
    
    В библиотеках тоже есть такой метод: http://lodash.com/docs#bind

8. напиши функцию `pluck`, которая берет массив объектов и возвращает массив значений определенного поля:
    
        var characters = [
          { 'name': 'barney', 'age': 36 },
          { 'name': 'fred', 'age': 40 }
        ];
    
        console.log(pluck(characters, 'name')); // ['barney', 'fred']

    Такая функция есть в lodash: http://lodash.com/docs#pluck
    
    Функция не должна изменять исходный массив.

9. напиши функцию `filter`, которая принимает функцию-предикат и массив. Возвращает она массив значений, для которых предикат вернет true.

        var input = [1, 2, 3, 4, 5, 6];
        function isEven(x) { return x % 2 == 0; } // проверяет на четность
        console.log(filter(input, isEven)); // [2, 4, 6]
        
    Функция не должна изменять исходный массив:
    
        console.log(input); // [1, 2, 3, 4, 5, 6]
    
    Аналог из lodash: http://lodash.com/docs#filter
    В новых браузерах у массивов есть метод `filter`.

10. Напиши функцию, считающую число свойств в объекте:

        var a = { a: 1, b: 2 };
        console.log(count(a)); // 2
        var b = function () {};
        console.log(count(b)); // 0
        var c = [1, 2, 3];
        console.log(count(c)); // 3
        var d = [];
        d[100] = 1;
        console.log(count(d)); // 1    
        
11. дан список вида «страна, город, население»: http://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BC%D1%8B%D0%B5_%D0%BD%D0%B0%D1%81%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D0%B5_%D0%B0%D0%B3%D0%BB%D0%BE%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B

    Можешь взять оттуда первые 5-10 городов и перенести в код. Города в списке могут идти в произвольном порядке. Напиши программу, которая отберет и выведет N самых населенных городов по убыванию числа жителей.

12. Некая сеть фастфудов предлагает несколько видов гамбургеров:

  - маленький (50 тугриков, 20 калорий)
  - большой (100 тугриков, 40 калорий)

  Гамбургер может быть с одним из нескольких видов начинок (обязательно):

  - сыром (+ 10 тугриков, + 20 калорий)
  - салатом (+ 20 тугриков, + 5 калорий)
  - картофелем (+ 15 тугриков, + 10 калорий)

  Дополнительно, гамбургер можно посыпать приправой (+ 15 тугриков, 0 калорий) и полить майонезом (+ 20 тугриков, + 5 калорий). Напиши программу, расчиытвающую стоимость и калорийность гамбургера. Используй ООП подход (подсказка: нужен класс Гамбургер, константы, методы для выбора опций и рассчета нужных величин).

  Код должен быть защищен от ошибок. Представь, что твоим классом будет пользоваться другой программист. Если он передает неправильный тип гамбургера, например, или неправильный вид добавки, должно выбрасываться исключение (ошибка не должна молча игнорироваться).

13\. В одном городе есть электрическая сеть. К ней могут быть подключены:

- электростанции, вырабатывают мощность от 1 до 100 мегаватт 
- солнечные панели, генерируют от 1 до 5 мегаватт днем (в зависимости от вида панели, то есть есть панели, которые генерируют 1 мегаватт, есть которые 2 и так далее) и 0 ночью
- жилые дома, в них от 1 до 400 квартир, потребляют 4 кВт на квартиру днем и 1 кВт ночью.
- линии электропередач, ведущие в другие города, по ним может подаваться недостающая или отдаваться лишняя энергия. У линий есть свойство «мощность», которая определяет, сколько мегаватт можно передать по ней, а также «цена мегаватта», которое показывает сколько можно получить или придется заплатить за переданный/полученный мегаватт. На разных линиях может быть разная цена.

Дан список всех элементов электросети. Напиши программу, рассчитывющую, сколько электричества необходимо закупить (или можно продать) днем и ночью для обеспечения баланса и сколько это будет стоить (или принесет прибыли). Используй продвинутый ООП подход для решения задачи.    

14\. напиши функцию, определяющую тип переменной. Результат должен быть одной из строк: `'undefined', 'boolean' (для true/false), 'null', 'number', 'string', 'function', 'array', 'array-like', 'object'`

array-like — это псевдомассив, то есть объект, у которого есть неотрицательное свойство `length` и элементы с `0` до `length - 1`.

Псевдомассивом например является `arguments`, а также DOM-коллекции (с которыми ты столкнешься позже).
    
В JS есть оператор `typeof`, но у него есть подвохи:

- `typeof null` дает `'object'`
- `typeof []` дает `'object'`

Определение массива через `[] instanceof Array` не сработает, если массив был создан в друго вкладке или фрейме браузера, так как в каждой вкладке свой объект `window` и свой `window.Array`.

В новых браузерах появился метод `Array.isArray` ( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray ), но хорошо бы иметь универсальное решение. 

Обычно для решения этой задачи используется хак с `Object.prototype.toString.call(...)`

15\. Напиши функцию неглубокого копирования объектов и массивов.

По умолчанию, как ты наверно, знаешь, при копировании объектов или массивов (которые являются объекты) мы копируем лишь ссылку на тот же самый объект: 

        var a = [1, 2, 3];
        var b = a; // b указывает на тот же массив
        b.push(4);
        console.log(a); // [1, 2, 3, 4]

Функция неглубокого копирования должна создавать новый массив/объект, и копировать в него элементы из старого. При этом сами элементы копируются по ссылке:
    
        var a = { x: 1, y: 2, z: [1, 2, 3] };
        var b = shallowCopy(a); // b — это отдельный объект
        b.x = 10;
        console.log(a.x); // 1
        
        // Но a.z и b.z указывают на один и тот же массив: 
        b.z.push(4);
        console.log(a.z); // [1, 2, 3, 4]
        
Если в функцию копирования передан объект `Date`, надо создавать копию того же типа.
    
        var с = new Date(2014, 1, 1);
        var d = shallowCopy(c);
        d.setFullYear(2015);
        console.log(c.getFullYear()); // 2014
    
В библиотеке lodash для неглубокого копирования есть функция clone: http://lodash.com/docs#clone
        
16\. Напиши функцию глубокого копирования объектов и массивов. Она должна делать не только копию переданного объекта/массива, но и копии вложенных  них объектов/массивов. Также, копироваться должны объекты `Date`

        var a = { x: 1, y: 2, z: [1, 2, 3], w: new Date(2014, 1, 1, 12, 0, 0) };
        var b = deepCopy(a); // b — это отдельный объект
        b.x = 10;
        console.log(a.x); // 1
        
        // a.z и b.z указывают на разные массивы: 
        b.z.push(4);
        console.log(a.z); // [1, 2, 3]
        
        // a.w и b.w независимы друг от друга
        b.w.setFullYear(2015);
        console.log(a.w.getFullYear()); // 2014

Решать можешь потом, так как сейчас не факт что ты сможешь их решить. Правильные ответы можно увидеть например в коде библиотеки lodash:
    
- http://lodash.com/docs#isArray
- http://lodash.com/docs#cloneDeep

## DOM, который построил Джек

Дальше идут задания на работу с DOM и событиями. DOM = Document Object Model — это набор объектов, которые соответствуют содержимому HTML-страницы, и позволяют взаимодействовать с и изменять содержимое страницы в браузере. Обычно каждому тегу на странице соответствует отдельный узел дерева DOM. Узлы образуют дерево, и для каждого узла можно получить родительский узел, список узлов-детей, соседние узлы.

CSSOM = CSS Object Model — это свойства и методы этих объектов, которые позволяют изменять CSS-стили элементов, а также получать информацию об их размерах и положении.

События в браузере — это события движения мыши, нажатия клавиш, прокрутки страницы. Ты можешь подписываться на эти события, и твой код будет вызваться в случае их возникновения. 

Теория для изучения (читать можно параллельно с решением задач): 

- http://javascript.ru/tutorial/dom
- http://javascript.ru/unsorted/w3c
- http://learn.javascript.ru/document
- http://learn.javascript.ru/events-and-interfaces
- http://learn.javascript.ru/css-for-js

Информация о поддержке а браузере тех или иных фич: http://caniuse.com/
Таблица свойств CSSOM: http://www.quirksmode.org/dom/w3c_cssom.html
Таблица видов событий: http://www.quirksmode.org/dom/events/

Задачки надо решать без использования сторонних библиотек (вроде JQuery).

Задачки:

### 1.Работа с классами

Дан узел DOM. Сделай функции `dom.hasClass(node, klass)`, a`dom.addClass(node, klass)`, `dom.removeClass(node, klass)` (`dom` — это обычный объект `{}`), которые позволяют проверить, есть ли у элемента заданный CSS-класс, добавить к нему класс (если его еще нет) и удалить класс. 

Если удалены все классы, то удалять аттрибут `class=""` не надо, пусть остается.

Примеры: 

    // вспомогательная функция для создания ноды
    function createNode(name, klasses) {  
        var n = document.createElement(name);
        n.className = klasses;
        return n;
    }
    
    function l(x) {
        console.log(x);
    }
    
    l(hasClass(createNode('div', 'test'), 'test')); // true
    l(hasClass(createNode('div', 'test'), 'tes')); // false
    
    l(hasClass(createNode('div', 'test1 test2'), 'tes')); // false
    l(hasClass(createNode('div', 'test1 test2'), 'test1')); // true
    
В современных браузерах и HTML 5 у узлов DOM есть объект classList для этого:

- https://developer.mozilla.org/en-US/docs/Web/API/Element.classList (англ.)
- http://html5.by/blog/javascript-classlist-api/

Но решение должно работать и в браузерах без classList.

### 2. Поле

Сделай поле из белых клеточек (клеточка может иметь размер около 28×28 пикселей). При клике на клеточку она должна менять цвет на черный. Под таблицей должна быть кнопка «поменять цвета». При ее нажатии все цвета клеточек меняются на противоположные.

Делать поле удобно с помощью элемента `<table>`. Саму таблицу надо не вставить в исходный код, а сгенерировать и добавить в DOM страницы яваскриптом. 

У тебя может возникнуть желание поставить обработчик события на каждую клеточку. Не делай так, это неэффективно, достаточно одного обработчика на всю таблицу.

Чтобы поменять цвета всех клеточек сразу, необязательно обходить их в цикле. Если помечать нажатые клетки определенным классом, то перекрасить их все одновременно можно, поменяв класс на самой таблице.

### 3. Сапер

Сделал поле из предыдущей задачи? Отлично, давай превратим его в игру «Сапер». Wiki: http://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BF%D1%91%D1%80_(%D0%B8%D0%B3%D1%80%D0%B0) 

Идея игры такая: на игровом поле где-то спрятаны мины. Игрок кликает по клеткам, открывая их. Если в клетке была мина, игрок проиграл. Если нет, то в клетке выводится цифра, показывающая общее число мин в соседних 8 клетках. Если игрок открыл все клетки, кроме заминированных, он победил. Если игрок открывает клетку, рядом с которой нет мин, то все соседние клетки открываются автоматически (если на них тоже нет мин, то процесс продолжается).

Правой кнопкой мыши на неоткрытых клетках можно расставлять флажки.

Надпись «Вы победили» или «Вы проиграли» должна выводиться в окошке поверх игрового поля и содержать кнопку «Новая игра».

В качестве иконки для бомбы и флажка можешь взять какой-нибудь юникодный символ отсюда: http://unicode-table.com/ru/#miscellaneous-symbols
    
### 4. Поиск по селектору

Напиши функцию `dom.find(selector, context)` которая ищет все элементы, соответствующие селектору `selector` внутри элемента `context` (если он не указан, то во всем документе). В `selector` можно использовать такие выражения:

- поиск по имени тега `div`
- поиск по одному или нескольким классам `.some-class.some-other-class`
- поиск по id `#element`
- поиск одного элемента внутри другого `.parent#some-id   div.child`

Функция должна быть максимально кроссбраузерной, то есть использовать при наличии поддержки такие функции: `querySelectorAll()`, `getElementsByClassName()`, `getElementsByTagName()`. Собственно, если `querySelectorAll()` есть, то можно сразу передать ей селектор, а в остальных случаях придется немного помучаться.

Я советую разобрать селектор на массив условий вида `{ tagName: null, classes: ['a', 'b'], id: null }` с которыми работать будет проще. Распарсить можно например регулярными выражениями.

Функция поиска по селектору (причем с более мощными возможностями) есть во многих библиотеках, например, в JQuery.
   
### 5. Анимация
   
Напиши «класс» `dom.Animation(node, styles, options)` для анимированного изменения CSS-свойств. В `node` передается узел, который мы хотим анимировать, в `styles` — набор стилей, к которым должен придти объект в итоге, в `options` можно указать такие опции: 

- `duration` — время анимации в секундах (по умолчанию 0.3 cек)
- `onEnd` — функция, которая будет вызвана после завершения анимации
- `onTick` — функция, которая будет вызываться на каждом шаге анимации и получать в качестве аргумента число от 0 до 1 показывющее, какая часть времени анимации уже прошла

В `styles` можно указать не только названия CSS-свойств в виде `marginTop: 12` но и значения `scrollLeft`, `scrollTop` — они должны анимированно менять значения соответствующих свойств. Значения для свойств должны быть указаны в `px` (а то ты замучаешься писать код). Для свойства `opacity` указывается число от 0 до 1. Другие свойства (которые не выражаются числом, например, цвет) анимировать нельзя.

У объектов класса `dom.Animation` так же должны быть реализованы такие методы: 

- `isActive()` - возвращает `true` если анимация сейчас выполняется и `false` в противоположном случае
- `stop()` - останавливает выполнение анимации, оставляя значения свойств в текущем состоянии
- `stopForProperties(props)` - останавливает выполнение анимации для указанных свойств

Если для одного узла создается несколько анимаций, то более поздние анимации свойств отменяют действие более старых. Например, если мы сначала пытаемся анимировать width до 300px, а потом до 500px то вторая анимация при запуске останавливает первую.

Если в браузере есть поддержка CSS-transition, и не указана анимация свойств `scrollTop/scrollLeft` и функция `onTick`, то должны использоваться они. Если нет, то стоит исплользовать анимацию через `requestAnimationFrame()` (если ее нет то через `setTimeout()`).

Если выполняется несколько анимаций, они должны выполняться одним блоком (для всех анимация должен использоваться общий таймер), иначе код будет работать неэффективно (так как браузер делает перерисовку после завершения обработки события таймера, то в случае нескольких таймеров она будет делаться несколько раз).

Не пытайся каждый шаг увеличивать значение свойства на постоянную величину, так как браузер не гарантирует что твоя функция будет вызываться строго равномерно. Вместо этого считай сколько времени прошло и сколько процентов анимации должно выполниться к этому моменту.

Пример вызова: 

        var node = document.getElementById('test');
        var animation = new dom.Animation(node, {
            width: 300,
            marginTop: 500
        }, {
            duration: 1,
            onEnd: function () {
                console.log('Ended!');
            }
        });
        
### 6. Плавный скроллинг
        
Имея класс для анимации, сделай плавную прокрутку при клике на якорь (якорь — это ссылка внутри страницы вроде `<a href="#some-id">...</a>`. При клике на нее страница прокручивается к элементу с `id="some-id"`).

### 7. Галерея

Сделай просмотрщик картинок. На странице есть список из нескольких элементов `<img>` содержащих превьюшки и ссылку на большую картинку в аттрибуте `data-image-src`, а над ним — область просмотра картинок. При клике по превьюшке картинка в области просмотра должна плавно заменяться на выбранную.

### 8. ClearInputWidget

Сделай виджет `ClearInputWidget`, добавляющий справа в поле ввода крестик, нажатие на которое очищает его. Чтобы содержимое поля ввода не накладывалось на крестик, надо задать ему соответствующий padding. Виджет должен работать с полями ввода любых размеров, цветов (в том числе с белым текстом на серном фоне) и с любыми значениями padding. Крестик удобно нарисовать с помощью какого-нибудь юникодного символа, например http://unicode-table.com/ru/274C/

При очистке поля должны генерироваться событие `input` и `change` (по идее оно должно генерироваться само при уходе фокуса с инпута, но фокус может уйти раньеш чем поменяелся знаечения в инпуте) так, что если кто-то подписался на события, то узнает о том, что поле изменило значение. Для верности, стоит еще генерировать пару `keydown`/`keyup`, например имитирующих нажатие Backspace. 

Например, представь, к этому полю подключен скрипт, который выводит число введенных символов. Если мы не сгенерируем события, то скрипт не узнает что поле очистилось и не обновит цифру.

Вот описание разных событий которые есть у элементов форм: http://learn.javascript.ru/events-change

### 9. Фильтр

Сделай виджет для фильтрации списков и таблиц. Допустим, на странице есть таблица или список (или просто набор div) и поле ввода. Надо сделать виджет, позволяющий при вводе текста в это поле скрывать строки таблицы/элементы списка/узлы, в которых текста нет. Пример использования: 

    var table = document.getElementById('someTable');
    var input = document.getElementById('someInput');
    var filter = new InputFilter(table, input);
    filter.clear(); // очищает фильтр
    filter.setValue('test'); // вставляет слово test в фильтр

У объекта `filter` должны быть методы `clear()` и `setValue()`. 

Фильтр должен быть универсальным, то есть не требовать какой-то особенной структуры HTML-кода, чтобы его можно было подключить на любую страницу. Фильтр должен корректно работать в сочетании с `ClearInputWidget` из предыдущей задачи.

Для фильтрации таблиц надо как-то предусмотреть возможность запретить скрывать самую первую строчку с заголовками (лучше N первых строчек).

Этот фильтр может скрывать строки в таблице, но им нельзя например, отфильтровать список картинок по тегам (которые указаны например в аттрибуте `data-tags`). Давай это исправим! Сделай возможность указать функцию `getFilterText(node)` которая получает по очереди каждый элемент списка и должна вернуть текст, который ему соответствует (по которому проводится фильтрация).

Фильтр должен игнорировать регистр букв, знаки препинания, различия в числе пробелов (то есть фильтру `hello world` соответствует строка `Hello, !!! world`).

Подумай об оптимизациях кода. Например, как при добавлении буквы не проверять уже скрытые узлы, или как можно кешировать текст элемента списка (так как его получение может занимать время).

Усложненная версия: сделай возможность подсвечивать текст, который введен в фильтр, в отфильтрованном списке.

### 10. Автокомплит

Сделай виджет `AutocompleteInput` для реализации автодополнения (по тому же принипу как вываливаются подсказки в гугле или яндексе при вводе слова). Виджет вешается на любой input, любого цвета и размера. Если input находится внизу страницы или внизу окна браузера, то список подсказок должен вываливаться над ним, а не под ним. Список подсказок должен по ширине быть не меньше чем input.

По списку подсказок можно перемещаться стрелками, а также двигая мышь, при этом выбранная посказка показывается серым цветом в поле ввода.

Размер списка подсказок (и цвет серой подсказки) задается в опциях виджета.

Для получения подсказок пользователь передает функцию. Эта функция вызвается по мере ввода текста и должна вернуть список вариантов для подсказки. Функция должна поддерживать асинхронность (например, подсказки получаются с сервера — значит мы не можем сразу вернуть результаты, а только когда придет ответ). Для этого функция должна выглядть так: 

        function getSuggestions(keyword, onDone, onError) {
            ....
        }
        
Когда функция готова будет передать список слов для подсказки, она сделает вызов `onDone(words)`. Если ей не удастсяэ это сделать, она может вызвать `onError()`.

Виджет должен поддерживать клавиши: `↑`, `↓`, `PgUp`, `PgDn` — выбирают варианты в списке, если он закрыт то раскрывают список, `Esc` — закрывает список, `Enter` — если список раскрыт, то выбирает выделенный вариант и закрывает список.
    
### 11. Ексель
    
Сделай виджет `EditableTable` который позволяет сделать таблицу редактируемой наподобие Excel. После запуска этого виджета на таблице появляется рамка, которую можно перемещать стрелками, клавишами `PgUp`, `PgDn`, `Home`, `End` и одиночным кликом мыши. При двойном клике по ячейке или нажатии `F2` она переходит в режим редактирования и рамка превращается в поле ввода. Также, в режим редактирования можно перейти, нажав букву, символ или цифру, при этом содержимое ячейки очищается.

Надо предусмотреть возможность через опции запретить редактировать заголовки (элементы `th`) и ячейки, которые помечены специальным аттрибутом (например `data-readonly`).

При перемещении рамки стрелками за край окна, окно должно плавно прокручиваться, чтобы рамка стала видимой.

Усложненная версия: при двойном клике курсор в поле ввода должен ставиться в место клика.

   