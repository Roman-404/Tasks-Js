\1. Напиши функцию создания генератора `sequence()`. Она при вызове возвращает другую функцию-генератор, которая при каждом вызове дает число на 1 больше, и так до бесконечности. Начальное число, с которого начинать отсчет, и шаг, задается при создании генератора. Шаг можно не указывать, тогда он будет равен одному. Начальное значение по умолчанию равно 0.

    var generator = sequence(10, 3);
    console.log(generator()); // 10
    console.log(generator()); // 13
    console.log(generator()); // 16
    console.log(generator()); // 19

2. Также, нужна функция `take(gen, x)` которая вызвает функцию `gen` заданное число (`x`) раз и возвращает массив с результатами вызовов. Она нам пригодится для отладки:

    var gen2 = sequence(0, 2);
    console.log(take(gen2, 5)); // [0, 2, 4, 6, 8 ]


3. Напиши функцию `map`, которая принимает на вход функцию и массив, и обрабатывает каждый элемент массива этой функцией, возвращая новый массив. Пример: 

    function square(x) { return x * x; } // возведение в квадрат
    console.log(map(square, [1, 2, 3, 4])); // [1, 4, 9, 16]
    console.log(map(square, [])); // []
    
Это аналог `array_map` из PHP.

4. Напиши функцию `fmap`, которая принимает на вход 2 функции, a и gen, где `gen` — функция-генератор вроде той, что была в первом задании. fmap возвращает новую функцию-генератор, которая при каждом вызове берет следующее значение из gen и пропускает его через функцию a. Пример: 

    var gen = sequence(1, 1);
    function square(x) { return x * x; }
    var squareGen = fmap(square, gen);
    
    console.log(squareGen()); // 1
    console.log(squareGen()); // 4
    console.log(squareGen()); // 9
    console.log(squareGen()); // 16

А, еще, сделай тогда, чтобы в качестве `counter()` можно было указать функцию с аргументами, и при вызове

    squareCounter(1, 2, 100);

Эти аргументы бы передавались функции `counter()`. Аргументов может быть любое количество.

5. Частичное применение (partial application)

вики: http://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5

Напиши функцию `partial(fn, a1, a2, ....)`, которая позволяет зафиксировать один или несколько аргументов функции. Пример: 

    function add(a, b) { return a + b; }
    function mult(a, b, c, d) { return a * b * c * d; }
    
    var add5 = partial(add, 5); // Мы получили функцию с 1 аругментом, которая прибавляет к любому числу 5
    
    console.log(add5(2)); // 7
    console.log(add5(10)); // 15
    console.log(add5(8)); // 13
    
    var mult23 = partial(mult, 2, 3); // мы зафиксировали первые 2 аргумента mult() как 2 и 3
    
    console.log(mult23(4, 5)); // 2*3*4*5 = 120
    console.log(mult23(1, 1)); // 2*3*1*1 = 6

Есть функция с аргументами: 

    f1(a, d, c, d)

Мы можем с помощью `partial` сделать из нее функцию с меньшим числом аргументов, заранее задав значения для нескольких из них, например:

    var f2 = partial(f1, 1, 2); // фиксируем a = 1, b = 2

И вызов:

    f2(x, y)

будет равносилен вызову:

    f1(1, 2, x, y)

Кстати, имеющийся в новых версиях JS метод `bind()` тоже может делать частичное применение: http://frontender.info/partial-application-in-javascript-using-bind/ Но ты должен обойтись без его использования, и написать свой велосипед.

6. Наша функция `partial` позволяет фиксировать только первые аргументы. Усовершенствуй ее, чтобы зафиксировать можно было любые аргументы, пропущенные аргументы обозначаются с помощью undefined:

    function test(a, b, c) { return 'a=' + a + ',b=' + b + ',c=' + c; }
    var test1_3 = partial(test, 1, undefined, 3);
    console.log(test1_3(5)); // a=1,b=5,c=3
    
7. напиши функцию `bind`, которая позволяет привзяать контекст (значение `this`) к функции:

    window.x = 1;
    var ctx = { x: 2 };

    function testThis() { console.log(this.x); }
    testThis(); // 1
    var boundFunction = bind(testThis, ctx);
    boundFunction(); // 2

В новых браузерах и функций есть метод `bind()`, делающий аналогичную вещь: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

В библиотеках тоже есть такой метод: http://lodash.com/docs#bind

8. напиши функцию `pluck`, которая берет массив объектов и возвращает массив значений определенного поля:

    var characters = [
      { 'name': 'barney', 'age': 36 },
      { 'name': 'fred', 'age': 40 }
    ];

    pluck(characters, 'name'); // ['barney', 'fred']

Такая функция есть в lodash: http://lodash.com/docs#pluck

9. напиши функцию `filter`, которая принимает функцию-предикат и массив. Возвращает она массив значений, для которых предикат вернет true.

    var input = [1, 2, 3, 4, 5, 6];
    function isEven(x) { return x % 2 == 0; } // проверяет на четность
    console.log(filter(isEven, input)); // [2, 4, 6]

Аналог из loash: http://lodash.com/docs#filter
В новых браузерах у массивов есть метод `filter`.

10. Напиши функцию, считающую число свойств в объекте:

    var a = { a: 1, b: 2 };
    count(a); // 2
    var b = function () {};
    count(b); // 0
    var с = [1, 2, 3];
    count(c); // 3
    var d = [];
    d[100] = 1;
    count(d); // 1    
    
11. дан список вида «страна, город, население»: http://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BC%D1%8B%D0%B5_%D0%BD%D0%B0%D1%81%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B3%D0%BE%D1%80%D0%BE%D0%B4%D1%81%D0%BA%D0%B8%D0%B5_%D0%B0%D0%B3%D0%BB%D0%BE%D0%BC%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B

Можешь взять оттуда первые 5-10 городов и перенести в код. Города в списке могут идти в произвольном порядке. Напиши программу, которая отберет и выведет N самых населенных городов по убыванию числа жителей.

12. Некая сеть фастфудов предлагает несколько видов гамбургеров:

* маленький (50 тугриков, 20 калорий)
* большой (100 тугриков, 40 калорий)

Гамбургер может быть с одним из нескольких видов начинок (обязательно):

* сыром (+ 10 тугриков, + 20 калорий)
* салатом (+ 20 тугриков, + 5 калорий)
* картофелем (+ 15 тугриков, + 10 калорий)

Дополнительно, гамбургер можно посыпать приправой (+ 15 тугриков, 0 калорий) и полить майонезом (+ 20 тугриков, + 5 калорий). Напиши программу, расчиытвающую стоимость и калорийность гамбургера. Используй ООП подход (подсказка: нужен класс Гамбургер, константы, методы для выбора опций и рассчета нужных величин).

13. В одном городе есть электрическая сеть. К ней могут быть подключены:

* электростанции, вырабатывают мощность от 1 до 100 мегаватт
* солнечные панели, генерируют от 1 до 5 мегаватт днем и 0 ночью
* жилые дома, в них от 1 до 400 квартир, потребляют 4 кВт на квартиру днем и 1 кВт ночью.
* линии электропередач, ведущие в другие города, по ним может подаваться недостающая или отдаваться лишняя энергия.

Дан список всех элементов электросети. Напиши программу, рассчитывющую, сколько электричества необходимо закупить (или можно продать) днем и ночью для обеспечения баланса. Используй продвинутый ООП подход для решения задачи.    

14. напиши функцию, определяющую тип переменной. Результат должен быть одной из строк: `'undefined', 'boolean' (для true/false), 'null', 'number', 'string', 'function', 'array', 'array-like', 'object'`

array-like — это псевдомассив, то есть объект, у которого есть неотрицательное свойство `length` и элементы с `0` до `length - 1`.

Псевдомассивом например является `arguments`, а также DOM-коллекции (с которыми ты столкнешься позже).

В JS есть оператор `typeof`, но у него есть подвохи:

- `typeof null` дает `'object'`
- `typeof []` дает `'object'`

Определение массива через `[] instanceof Array` не сработает, если массив был создан в друго вкладке или фрейме браузера, так как в каждой вкладке свой объект `window` и свой `window.Array`.

В новых браузерах появился метод `Array.isArray` ( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray ), но хорошо бы иметь универсальное решение.

15. Напиши функцию неглубокого копирования объектов и массивов.

16. Напиши функцию глубокого копирования объектов и массивов.

Решать можешь потом, так как сейчас не факт что ты сможешь их решить. Правильные ответы можно увидеть например в коде библиотеки lodash:

- http://lodash.com/docs#isArray
- http://lodash.com/docs#clone
- http://lodash.com/docs#cloneDeep
